把构造函数设置为private私有访问权限，可禁止外部创建对象。
参看section1。

【定义】
确保某一个类只有一个实例，且自行实例化并向整个系统提供这个实例。
Singleton类称为单例类，通过使用private的构造函数确保在一个应用中只产生一个实例，且是自行实例化的。
参看section3。

【优点】
①减少内存开支，特别是一个对象需频繁创建、销毁时，且创建或销毁时性能又无法优化；
②较少系统性能开销，eg.读取配置、产生其他依赖对象。用永驻内存方式解决（JVM垃圾回收机制）；
③可避免对资源的多重占用，eg.写文件；
④可在系统设置全局访问点，优化和共享资源访问，eg.可设计一个单例类，负责所有数据表的映射处理。

【缺点】
①一般单例模式无接口（除特殊情况，接口或抽象类是不能被实例化的），扩展困难（要改代码）；
②对测试不利，并发环境中，单例模式没完成，不能测试，无接口不能使用mock方法虚拟对象；
③与单一职责有冲突。它把要“单例”和业务逻辑融合在一个类。

【使用场景】
①要求生产唯一序列号的环境；
②项目的共享访问点或共享数据，eg.计数器（保证线程安全）；
③需消耗过多资源，eg.访问IO和数据库等资源；
④需定义大量静态常量和静态方法（如工具类，当然也可直接声明为static）。

【注意事项】
高并发，要注意单例模式的线程同步问题。
参看section4。

线程A执行到singleton = new Singleton()，但还没获得对象，线程B也执行到singleton == null判断，
线程A获得了一个对象，线程B也获得了一个对象，内存就出现两对象。

【扩展】
若要求一个类只能产生两三个对象。
eg.明朝土木堡之变明英宗被俘后，明景帝即位，那时期同时存在两个皇帝。
参看section2。

需要产生固定数量对象的模式叫做有上限的多例模式。
eg.读取文件，可在系统启动时完成初始化工作，
在内存中启动固定数量的reader实例，然后需读取文件时就可快速响应。

===================================================
【注意】
JVM的垃圾回收机制，若单例对象在内存长久不用，JVM就会视为垃圾，
在CPU资源空闲的情况下该对象会被清理，下次调用时需重新产生一个对象。
eg.计数器管理可能会出问题。

解决办法：
①由容器管理单例的生命周期；
    spring可让对象常驻内存。
②状态随时记录。
    使用异步记录，使用观察者模式，记录状态的变化，
    写入文件或写入数据库中，确保重新初始化的数据丢失问题。
