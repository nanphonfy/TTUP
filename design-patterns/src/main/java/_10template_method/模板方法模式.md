悍马车有两型号：H1和H2
需求只需悍马模型，先写个抽象类，然后两个不同型号的模型实现类。
抽象类中，定义了悍马模型必须具有的特质。

section1存在的问题：两个实现类的run方法都完全相同，那该run方法实现应出现在抽象类，不该在实现类。
抽象是所有子类的共性封装。

section2对其改进。
抽象的悍马模型已定义了run方法的执行规则，实现类不需实现run方法了。
这里用到的就是模板方法模式。

【定义】
定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可不改变一个算法的结构即可重定义该算法的某些特定步骤。
模板方法模型很简单，仅用到了java的继承。
抽象模板的方法分两类：
①基本方法；
基本操作，由子类实现，且在模板方法被调用。
②模板方法。
可有一个或几个，一般是个具体方法（框架），实现对基本方法的调度，完成固定逻辑。
【注意】为防止恶意操作，一般模板方法都加上final，不允许被覆写。
可参看section3。
抽象模板中的基本方法尽量设计为protected，符合"迪米特法则"，不需暴露的属性或方法尽量不要设置为protected。

【优点】
①封装不变部分，扩展可变部分；
把不变部分的算法封装到父类实现，可变部分通过继承继续扩展。
②提取公共部分代码，便于维护；
③行为有父类控制，子类实现 。
基本方法由子类实现，子类可扩展相应功能，符合开闭原则。

【缺点】
按设计习惯：抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。
模板方法模式却颠倒了，抽象类定义部分抽象方法（由子类实现，同时又影响父类结果）。
复制项目中，阅读难度，对新手有挑战。

【使用场景】
①多个子类有公有方法，且逻辑基本相同时；
②重要、复杂的算法，可把核心算法设计为模板方法，周边相关细节功能由子类实现；
③重构时，把相同代码抽取到父类，通过钩子函数（模板方法模式的扩展）约束其行为。

【钩子函数（模板方法模式的扩展）】
新需求：H1型号悍马喇叭想响才响，H2型号喇叭不要有声音。
参看section4。

抽象类增加一个实现方法isAlarm，确定各型号悍马是否需要声音，由实现类覆盖它。
其他基本方法不需对外提供访问，设计为protected类型。

抽象类的isAlarm返回值就是影响模板方法的执行，该方法叫做钩子方法。有了钩子方法模板方法模式才算完美。
修改子类，影响父类行为的结果，曲线救国的方式实现了父类依赖子类的场景，模板方法模型就是这种效果。






