【通过后台线程监控】
创建一个后台线程一直运行，一旦发现韩非子动态，就触发事件上报给李斯。

【通过聚集方式监控】
通过聚集方式的被观察者，引用LiSi实例，接口完全没修改，只修改实现类。
    通过聚集方式非常简单，但有问题。
    战国不止李斯在监视韩非子，且观察活动很广，eg.政治倾向、思维倾向、朝野活动等。
        聚集方式和开闭原则严重违背。

【改进后的观察者和被观察者】
原来的基础，做两个修改：
①增加Observable；
    实现该接口的都是被观察者。
②修改ILiSi接口名称为Observer。
    更抽象化，所有实现该接口的都是观察者（不止李斯）
结果正确，符合开闭原则，且实现类间解耦。
【这就是观察者模式。】

【定义】
观察者模式也叫发布订阅模式。定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，
所有依赖于它的对象都会得到通知并被自动更新。

①Subject被观察者
    必须能动态增加、取消观察者。一般是抽象类或实现类，管理观察者并通知观察者。
②Observer观察者
    接收到消息后处理；
③ConcreteSubject具体的被观察者
    定义自己的业务逻辑&通知哪些事件；
④ConcreteObserver具体的观察者
    每个观察者都有自己的处理逻辑。

【观察者模式的优点】
①观察者和被观察者间是抽象耦合的；
    不管增加观察者还是被观察者都容易扩展。
②建立一套触发机制。
    根据单一职责原则，把各个单一职责串联，形成一个触发链。

【观察者模式的缺点】
    需考虑开发效率和运行效率问题，一被观察者多观察者，开发调试较复杂。
    一般顺序执行，一个观察者卡壳，影响整体执行效率。一般采用异步，而多级触发时效率更让人担忧。

【注意事项】
观察者模式要解决的两个重点问题。
①广播链问题
    数据库触发器链问题，eg.表A写一个触发器（更新某字段后更新表B一条数据），表B也有触发器更新表C，表C也有触发器……
    数据库基本要瘫痪。
    观察者模式也有该问题，一个观察者也可为被观察者，链一旦建立，逻辑较复杂，可维护性差。
    建议最多出现一个对象既是观察者也是被观察者，消息最多转发一次（传递两次）
②异步处理问题
    被观察者发生动态，观察者（较多时，处理时间较长）做回应。
    异步处理考虑线程安全和队列问题。

【区别】
    与 "责任链模式" 最大的区别就是观察者模式在传播过程中消息是随时更改的。

【java世界的观察者模式】
扩展：
    JDK提供了java.util.Observable类，HanFeiZi只需继承父类，实现自己的逻辑方法即可，符合单一职责原则。
    java.util.Observer接口让观察者自己去实现。

【项目中真实的观察者模式】
真实环境，系统设计会对其进行改造或改装。
①观察者和被观察者间的消息沟通
    观察者中的update方法接受两个参数，一个是被观察者，一个是DTO（data transfer object）
②观察者响应方式
    一、采用多线程技术，异步架构；二、缓存技术，同步架构。
③被观察者尽量自己做主
    被观察者状态改变不一定要通知观察者，对被观察者的业务逻辑实现重载，eg.增加一个doSomething(boolean isNotifyObs)
    决定是否通知观察者，而不是消息到达观察者才判断是否消费。

【观察者模式生活案例】
文件系统
    目录下新建文件（被观察者），会通知目录管理器（观察者）增加该文件，并通知磁盘管理器（观察者）较少1KB空间。
猫鼠游戏
    夜晚猫（被观察者）叫，吓跑了老鼠（观察者），吵醒了主人（观察者）。
ATM取钱
    多次输错密码，卡被吞，触发事件有：①摄像头连续快拍；②通知监控系统，吞卡；③初始化ATM屏幕。
    前两个通过观察者模式完成，后面通过异常完成。
广播收音机
    电台广播（被观察者），可打开多个收音机收听（观察者）。

