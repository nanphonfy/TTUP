#### 数据依赖性
若两操作（有一个写操作）访问同一变量，此时它们就存在数据依赖性。
- 数据依赖分三类：
名称| 代码示例| 说明
---|---|---
写后读|a=1;b=a;|
写后写|a=1;a=2;|
读后写|a=b;b=1;|

>上面三种，只要重排序，程序执行结果就会改变。  
>>编译器和处理器在重排序时，会遵守数据依赖性，不会改变存在数据依赖关系（仅针对单个处理器执行的指令序列和单个线程执行操作）的两个操作执行顺序。

#### as-if-serial语义
>指不管怎么重排序，（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。

- 计算圆的面积
```
double pi = 3.14; //A
double r = 1.0; //B
double area = pi*r*r;//C
```

>上面三操作的数据依赖关系：A->C、B->C  
C不能被重排序到A和B的前面，而A和B无数据依赖关系，可重排序A、B。

>①A->B->C；  
②B->A->C；  
>>as-if-serial语义把单线程程序保护起来，使编译器、runtime和处理器产生幻觉：单线程程序是按顺序执行。  
使程序员无需担心重排序和内存可见性问题。

#### 程序顺序规则
>根据happens-before的程序顺序规则，根据传递性分析以上代码的关系：  
①A happens-before B；  
②B happens-before C；  
③A happens-before C。

>实际上B可排在A前。如果A happens-before B，JMM并不要求A一定要在B前执行，仅要求前一个操作（执行结果）对后一操作可见，且前一操作按顺序排在第二个操作之前。  
A->B->C和B->A->C执行结果一致，故JMM认为该种重排序不非法。  
计算机中，软件、硬件技术都有共同目标：在不改变程序执行结果的前提下，尽可能的开发并行度（编译器和处理器、JMM都遵从）。

#### 重排序对多线程的影响
```java 
public class ReorderExample {
    int a = 0;
    boolean flag = false;

    void write() {
        a = 1;//1
        flag = true;//2
    }

    void read() {
        if (flag) {//3
            int i = a * a;//4
            //...
        }
    }
}
```
>flag变量用于标记变量a是否已被写入。  
假设A、B两线程，A先执行writer，B再执行reader方法，B执行操作4时，能否看到A在操作1对共享变量a的写入？不一定。
>>操作1和2无数据依赖关系，操作3和4也无数据依赖关系，编译器和处理器可对两操作重排序。

-- 操作1、2的多线程重排序  
![操作1、2的多线程重排序](https://raw.githubusercontent.com/nanphonfy/note-images/master/TTUP/understanding-the-jvm/understanding-java-memory-model/02/multi-thread-reorder.png)  
>线程A首先写flag，随后线程B读该变量，由于条件为真，线程B读取变量a，此时变量a还没被线程A写入，这里的多线程程序语义被重排序破坏了。

-- 操作3、4的多线程重排序   
![操作3、4的多线程重排序](https://raw.githubusercontent.com/nanphonfy/note-images/master/TTUP/understanding-the-jvm/understanding-java-memory-model/02/multi-thread-reorder2.png)  

>程序中，操作3、4存在控制依赖关系（会影响执行序列执行的并行度）。为此，编译器和处理器会采用猜测执行，克服控制相关性对并行度的影响。

- 处理器的猜测执行
>①线程B的处理器可提前读取并计算a*a；  
②把计算结果临时保存在重排序缓冲的硬件缓存中；  
③当操作3判断为真，把结果写入变量i。
>>猜测执行实质上对操作3、、4做了重排序（破坏了多线程程序语义）。  

在单线程程序，对存在控制依赖的操作重排序不会改变执行结果（as-if-serial语义允许对存在控制依赖的操作做重排序的原因）；  
在多线程程序，对存在控制依赖的操作重排序，可能会改变程序的执行结果。

### 顺序一致性
#### 数据竞争与顺序一致性保证
>程序未正确同步时，可能存在数据竞争。  
JMM规范数据竞争定义：  
在A线程写一个变量x，在B线程读x变量，写和读没通过同步排序。
>>若多线程能正确同步，该程序将无数据竞争。

- JMM对正确同步多线程的内存一致性保证：
>若程序正确同步（广义的：synchronized、volatile、final），执行将具有一致性——程序执行结果与程序在顺序一致性内存模型的执行结果相同。

#### 顺序一致性内存模型
>是理想化的理论参考模型，提供极强的内存可见性保证。

- 两大特性：
>①一个线程中的所有操作必须按照程序顺序执行；  
②（无论是否同步）所有线程只能看到单一的执行顺序（每个操作都必须原子执行且立即对所有线程可见）。

- 顺序一致性视图  
>概念上，顺序一致性模型有一个单一全局内存（左右摆动开关连接任意一个线程——必须按照程序顺序执行内存读/写）。  
任意时间点最多只能有一个线程连接内存，多线程并发时，开关能把内存读/写串行化。

- 线程A（A1->A2->A3）、线程B（B1->B2->B3）并发执行。  

>假设两线程使用监视器锁正确同步，线程A执行三操作后释放监视器锁，随后线程B获取其监视器锁。

图片。。。。。。。。

>假设两线程没做同步。

图片。。。。。。。。

>未同步程序在顺序一致性模型中虽整体无序，但所有线程都只能看到一致的整体执行顺序（因为在该模型中，每个操作都必须立即对任意线程可见）。  
但，JMM没有顺序一致性保证。未同步，在JMM整体无序，所有线程看到的执行顺序可能也不一致。  
eg.A线程写过的数据缓存在本地内存，还没刷新到主内存前，写操作仅对当前线程可见；其他线程会认为该写操作没被执行（当前线程和其他线程看到的操作顺序可能不一致）。

#### 同步程序的顺序一致性效果  
```java 
public class SynchronizedExample {
    int a = 0;
    boolean flag = false;

    // 获取锁
    public synchronized void writer() {
        a = 1;// 1
        flag = true;// 2
    }
    // 释放锁

    // 获取锁
    public synchronized void readder() {
        if (flag) {// 3
            int i = a * a;// 4
            // ...
        }
    }
    // 释放锁
}
```

>假设A线程执行writer后，B线程执行reader，在正确同步的多线程程序里，在JMM的执行结果将与在顺序一致性模型中执行结果相同。

>顺序一致性模型中，所有操作按程序顺序串行执行，JMM中，临界【区内】代码可重排序。虽线程A在临界区内做了重排序，监视器的互斥执行，导致线程B无法观察到A在临界区内的重排序（提高执行效率，又没改变执行结果）。

#### 未同步程序的执行特性
>对未同步或未正确同步的多线程程序，JMM只提供最小安全性：JVM在堆上分配对象，会先清零内存空间，然后分配对象（此时域的默认初始化已完成）。