eden s0 s1 tenured
新生代&老年代
绝大多数对象都是在新生代产生，eg.栈分配会在栈上，大对象超过阈值可能直接分配到老年代。在gc时，如果新生代的对象能够幸存，会分配到幸存代（from、to，完全对称，大小一样，空间浪费比较厉害，每次使用只能使用一块）。

串行收集器：
只使用一个线程，在多核cpu会受局限。

full gc是老年代的回收。

并行收集器：
多线程不一定快哦，多核cpu，设置合理的参数。

parallel收集器
串行收集器在新生代和老年代的并行化

除了使用多线程之外，回收的策略基本保持一致。

垃圾回收的工作总量是一定的，如果把gc频率提高，每次花的时间就少，整体性能会受到影响。为了追求性能，可以降低gc频率，gc花的时间比较长，停顿相对就较长。

吞吐量指单位时间cpu是分在应用程序还是gc，很多用户请求，占用的cup时间越多，响应就越快。

要找到权衡点，再进行调优。

CMS收集器（老年代的回收器）
并发和并行
并发是指，垃圾回收器跟应用程序线程一起执行，交替执行。而不是开多个线程去执行（并行）。
停顿会相对减少，吞吐量会降低。
单纯的老年代收集器。

初始标记，会产生全局停顿。

重新标记，依然是独占cpu，也会产生全局停顿。

标记过程主要工作负载是在并发标记，标记的关键点会产生全局停顿。全局停顿尽可能缩小，不可能完全消除。

之所以使用并发清除，而不是使用并发压缩，是因为清理时，应用程序线程依然执行。并发压缩要重新整理内存空间，需要移动对象的内存位置，很难再让应用程序继续执行了。

cms收集器在gc后，应用很有可能还存在垃圾对象。

串行收集器、并行收集器在回收时，应用是全局停顿的，因此在他们执行时堆满了，运行完后堆会被清空且执行时，运用程序是暂停的，不会有影响。而cms就不一样了，和用户线程一起执行，当用户线程申请大量空间时，预留空间不够，导致concurrent mode failure。

当cms收集器预留空间不够，执行失败时，就启用串行收集器进行回收。系统可能会产生较长时间的停顿（可能堆空间不够用了）。

标记清除和标记压缩的异同
标记-清除在清理后，可能会产生碎片。
eg.数组申请5个单位空间，标记清除后可能无法分配（连续空间）。标记压缩则可以很顺利很快的分配。

这就是为什么串行收集器或并行收集器都使用标记压缩进行整理（没有碎片），CMS收集器标记清除，因为它更加关注停顿，如果使用标记压缩，为了能和应用程序并发执行，要尽量保证对象位置不改变。